# frozen_string_literal: true

require 'rails_helper'

RSpec.describe Vote, type: :model do
  # ====================
  # FACTORY TESTS
  # ====================

  describe 'factory' do
    it 'creates vote from factory' do
      vote = build(:vote)
      expect(vote.save).to be_truthy
      expect(vote.user).not_to be_nil
      expect(vote.election).not_to be_nil
      expect(vote.paper_authority).not_to be_nil
    end

    it 'creates deleted vote' do
      vote = create(:vote, :deleted)
      expect(vote.deleted_at).not_to be_nil
    end
  end

  # ====================
  # VALIDATION TESTS
  # ====================

  describe 'validations' do
    it 'requires user_id' do
      vote = build(:vote, user: nil)
      expect(vote).not_to be_valid
      expect(vote.errors[:user]).to include('must exist')
    end

    it 'requires election_id' do
      vote = build(:vote, election: nil)
      expect(vote).not_to be_valid
      expect(vote.errors[:election]).to include('must exist')
    end

    it 'requires voter_id after generation' do
      # voter_id is automatically generated by before_validation callback
      # This test verifies that validation requires voter_id to be present
      vote = Vote.new
      vote.valid? # Trigger validations

      expect(vote).not_to be_valid
      expect(vote.errors[:voter_id]).to include('no puede estar en blanco')
    end

    it 'validates uniqueness of voter_id scoped to user_id' do
      user = create(:user)
      election = create(:election)
      vote1 = create(:vote, user: user, election: election)

      vote2 = build(:vote, user: user, election: election)
      vote2.voter_id = vote1.voter_id

      expect(vote2).not_to be_valid
      expect(vote2.errors[:voter_id]).to include('ya est√° en uso')
    end

    it 'allows same voter_id for different users' do
      election = create(:election)
      user1 = create(:user)
      user2 = create(:user)

      vote1 = create(:vote, user: user1, election: election)
      vote2 = build(:vote, user: user2, election: election)
      vote2.voter_id = vote1.voter_id

      expect(vote2).to be_valid
    end
  end

  # ====================
  # CALLBACK TESTS
  # ====================

  describe 'callbacks' do
    it 'generates voter_id on create' do
      vote = build(:vote)
      vote.voter_id = nil

      expect(vote.save).to be_truthy
      expect(vote.voter_id).not_to be_nil
      expect(vote.voter_id.length).to be_positive
    end

    it 'generates agora_id on create' do
      vote = create(:vote)
      expect(vote.agora_id).not_to be_nil
    end

    it 'does not regenerate voter_id on update' do
      vote = create(:vote)
      original_voter_id = vote.voter_id

      vote.update(created_at: 1.hour.ago)

      expect(vote.reload.voter_id).to eq(original_voter_id)
    end
  end

  # ====================
  # CRUD OPERATION TESTS
  # ====================

  describe 'CRUD operations' do
    it 'creates vote' do
      expect { create(:vote) }.to change(Vote, :count).by(1)
    end

    it 'reads vote' do
      vote = create(:vote)
      found_vote = Vote.find(vote.id)

      expect(found_vote.id).to eq(vote.id)
      expect(found_vote.voter_id).to eq(vote.voter_id)
    end

    it 'updates vote' do
      vote = create(:vote)
      new_paper_authority = create(:user)

      vote.update(paper_authority: new_paper_authority)

      expect(vote.reload.paper_authority_id).to eq(new_paper_authority.id)
    end

    it 'soft deletes vote' do
      vote = create(:vote)

      expect { vote.destroy }.to change(Vote, :count).by(-1)

      expect(vote.reload.deleted_at).not_to be_nil
    end
  end

  # ====================
  # ASSOCIATION TESTS
  # ====================

  describe 'associations' do
    it 'belongs to user' do
      vote = create(:vote)
      expect(vote).to respond_to(:user)
      expect(vote.user).to be_an_instance_of(User)
    end

    it 'belongs to election' do
      vote = create(:vote)
      expect(vote).to respond_to(:election)
      expect(vote.election).to be_an_instance_of(Election)
    end

    it 'belongs to paper_authority' do
      vote = create(:vote)
      expect(vote).to respond_to(:paper_authority)
      expect(vote.paper_authority).to be_an_instance_of(User)
    end
  end

  # ====================
  # INSTANCE METHOD TESTS
  # ====================

  describe 'instance methods' do
    describe '#generate_voter_id' do
      it 'returns SHA256 hash' do
        vote = create(:vote)
        voter_id = vote.generate_voter_id

        expect(voter_id).not_to be_nil
        expect(voter_id.length).to eq(64) # SHA256 hex digest length
        expect(voter_id).to match(/^[0-9a-f]+$/)
      end

      it 'is consistent' do
        vote = create(:vote)
        voter_id1 = vote.generate_voter_id
        voter_id2 = vote.generate_voter_id

        expect(voter_id1).to eq(voter_id2)
      end

      it 'uses voter_id_template from election' do
        election = create(:election, voter_id_template: '%<user_id>s:%<election_id>s')
        vote = create(:vote, election: election)
        voter_id = vote.generate_voter_id

        expect(voter_id).not_to be_nil
        expect(voter_id.length).to eq(64)
      end
    end

    describe '#generate_message' do
      it 'returns formatted string' do
        vote = create(:vote)
        message = vote.generate_message

        expect(message).to include(vote.voter_id)
        expect(message).to include('AuthEvent')
        expect(message).to include(vote.scoped_agora_election_id.to_s)
        expect(message).to include('vote')
      end
    end

    describe '#generate_hash' do
      it 'returns HMAC hash' do
        vote = create(:vote)
        message = 'test_message'
        hash = vote.generate_hash(message)

        expect(hash).not_to be_nil
        expect(hash.length).to eq(64) # SHA256 HMAC hex digest length
        expect(hash).to match(/^[0-9a-f]+$/)
      end

      it 'is consistent for same message' do
        vote = create(:vote)
        message = 'test_message'
        hash1 = vote.generate_hash(message)
        hash2 = vote.generate_hash(message)

        expect(hash1).to eq(hash2)
      end
    end

    describe '#scoped_agora_election_id' do
      it 'returns election location vote_id' do
        vote = create(:vote)
        agora_id = vote.scoped_agora_election_id

        expect(agora_id).not_to be_nil
        expect(agora_id).to be_a(Integer)
      end
    end

    describe '#url' do
      it 'returns valid booth URL' do
        vote = create(:vote)
        url = vote.url

        expect(url).not_to be_nil
        expect(url).to include(vote.election.server_url)
        expect(url).to include('booth')
        expect(url).to include(vote.scoped_agora_election_id.to_s)
        expect(url).to include('vote')
      end

      it 'includes HMAC hash and message' do
        vote = create(:vote)
        url = vote.url

        # URL format: server_url/booth/agora_id/vote/hash/message
        parts = url.split('/')

        expect(parts.length).to be >= 7
        expect(parts[-3]).to eq('vote')
      end
    end

    describe '#test_url' do
      it 'returns valid test HMAC URL' do
        vote = create(:vote)
        url = vote.test_url

        expect(url).not_to be_nil
        expect(url).to include(vote.election.server_url)
        expect(url).to include('test_hmac')
      end

      it 'includes key, hash and message' do
        vote = create(:vote)
        url = vote.test_url

        # URL format: server_url/test_hmac/key/hash/message
        parts = url.split('/')

        expect(parts.length).to be >= 5
        expect(parts[-4]).to eq('test_hmac')
      end
    end
  end

  # ====================
  # SOFT DELETE (PARANOIA) TESTS
  # ====================

  describe 'soft delete (paranoia)' do
    it 'excludes soft deleted votes from default scope' do
      active_vote = create(:vote)
      deleted_vote = create(:vote, :deleted)

      votes = Vote.all

      expect(votes).to include(active_vote)
      expect(votes).not_to include(deleted_vote)
    end

    it 'includes soft deleted votes with with_deleted scope' do
      active_vote = create(:vote)
      deleted_vote = create(:vote, :deleted)

      votes = Vote.with_deleted

      expect(votes).to include(active_vote)
      expect(votes).to include(deleted_vote)
    end

    it 'restores soft deleted vote' do
      vote = create(:vote)
      vote.destroy

      expect(vote.deleted_at).not_to be_nil

      vote.restore

      expect(vote.reload.deleted_at).to be_nil
      expect(Vote.all).to include(vote)
    end
  end

  # ====================
  # EDGE CASE TESTS
  # ====================

  describe 'edge cases' do
    it 'handles vote without election having voter_id_template' do
      election = create(:election, voter_id_template: nil)
      vote = create(:vote, election: election)

      expect(vote.voter_id).not_to be_nil
      expect(vote.voter_id.length).to be_positive
    end

    it 'generates different voter_ids for different users' do
      election = create(:election)
      user1 = create(:user)
      user2 = create(:user)

      vote1 = create(:vote, user: user1, election: election)
      vote2 = create(:vote, user: user2, election: election)

      expect(vote1.voter_id).not_to eq(vote2.voter_id)
    end

    it 'generates different voter_ids for different elections' do
      user = create(:user)
      election1 = create(:election)
      election2 = create(:election)

      vote1 = create(:vote, user: user, election: election1)
      vote2 = create(:vote, user: user, election: election2)

      expect(vote1.voter_id).not_to eq(vote2.voter_id)
    end

    it 'handles missing user when creating vote' do
      vote = Vote.new(election: create(:election))

      expect(vote.save).to be_falsey
      expect(vote.errors[:user]).to include('must exist')
    end

    it 'handles missing election when creating vote' do
      vote = Vote.new(user: create(:user))

      expect(vote.save).to be_falsey
      expect(vote.errors[:election]).to include('must exist')
    end

    it 'adds error when voter_id cannot be generated due to missing election' do
      vote = Vote.new(user: create(:user))
      vote.valid?

      expect(vote.errors[:voter_id]).to include('No se pudo generar')
    end

    it 'adds error when voter_id cannot be generated due to missing user' do
      vote = Vote.new(election: create(:election))
      vote.valid?

      expect(vote.errors[:voter_id]).to include('No se pudo generar')
    end
  end

  # ====================
  # VOTER ID TEMPLATE TESTS
  # ====================

  describe 'voter_id_template_values' do
    let(:user) { create(:user, document_vatid: '12345678A') }
    let(:election) { create(:election) }
    let(:vote) { create(:vote, user: user, election: election) }

    it 'returns shared_secret when using shared_secret key' do
      template = '%<shared_secret>s'
      election.update(voter_id_template: template)
      voter_id = vote.generate_voter_id

      expect(voter_id).not_to be_nil
      expect(voter_id.length).to eq(64)
    end

    it 'returns secret_key_base when using secret_key_base key' do
      template = '%<secret_key_base>s'
      election.update(voter_id_template: template)
      voter_id = vote.generate_voter_id

      expect(voter_id).not_to be_nil
      expect(voter_id.length).to eq(64)
    end

    it 'returns user_id when using user_id key' do
      template = '%<user_id>s'
      election.update(voter_id_template: template)
      voter_id = vote.generate_voter_id

      expect(voter_id).not_to be_nil
    end

    it 'returns election_id when using election_id key' do
      template = '%<election_id>s'
      election.update(voter_id_template: template)
      voter_id = vote.generate_voter_id

      expect(voter_id).not_to be_nil
    end

    it 'returns scoped_agora_election_id when using scoped_agora_election_id key' do
      template = '%<scoped_agora_election_id>s'
      election.update(voter_id_template: template)
      voter_id = vote.generate_voter_id

      expect(voter_id).not_to be_nil
    end

    it 'returns normalized_vatid when using normalized_vatid key' do
      template = '%<normalized_vatid>s'
      election.update(voter_id_template: template)
      voter_id = vote.generate_voter_id

      expect(voter_id).not_to be_nil
    end

    it 'returns literal key for unknown keys' do
      template = '%<unknown_key>s'
      election.update(voter_id_template: template)
      voter_id = vote.generate_voter_id

      expect(voter_id).not_to be_nil
    end
  end

  # ====================
  # PRIVATE METHOD TESTS
  # ====================

  describe 'private methods' do
    describe '#normalized_vatid' do
      let(:vote) { build(:vote) }

      it 'returns DNI prefix for Spanish NIFs' do
        result = vote.send(:normalized_vatid, true, '12345678A')

        expect(result).to start_with('DNI')
      end

      it 'returns PASS prefix for passports' do
        result = vote.send(:normalized_vatid, false, 'AB123456')

        expect(result).to start_with('PASS')
      end

      it 'normalizes the identifier' do
        result = vote.send(:normalized_vatid, true, '12-345-678-A')

        expect(result).to eq('DNI12345678A')
      end
    end

    describe '#normalize_identifier' do
      let(:vote) { build(:vote) }

      it 'removes non-alphanumeric characters' do
        result = vote.send(:normalize_identifier, '12-345-678-A')

        expect(result).to eq('12345678A')
      end

      it 'converts to uppercase' do
        result = vote.send(:normalize_identifier, '12345678a')

        expect(result).to eq('12345678A')
      end

      it 'removes leading zeros from numeric groups' do
        result = vote.send(:normalize_identifier, '00012345A')

        expect(result).to eq('12345A')
      end

      it 'handles mixed alphanumeric with leading zeros' do
        result = vote.send(:normalize_identifier, '0001234A0005B')

        expect(result).to eq('1234A5B')
      end

      it 'preserves non-leading zeros' do
        result = vote.send(:normalize_identifier, '10203040A')

        expect(result).to eq('10203040A')
      end

      it 'handles identifiers with multiple groups' do
        result = vote.send(:normalize_identifier, 'AB-001234-CD-005678')

        expect(result).to eq('AB1234CD5678')
      end
    end

    describe '#number?' do
      let(:vote) { build(:vote) }

      it 'returns true for numeric characters' do
        ('0'..'9').each do |char|
          expect(vote.send(:number?, char)).to be true
        end
      end

      it 'returns false for alphabetic characters' do
        ('A'..'Z').each do |char|
          expect(vote.send(:number?, char)).to be false
        end
      end

      it 'returns false for special characters' do
        ['-', '_', '.', ' '].each do |char|
          expect(vote.send(:number?, char)).to be false
        end
      end
    end
  end

  # ====================
  # COMBINED SCENARIO TESTS
  # ====================

  describe 'combined scenarios' do
    it 'completes vote creation workflow' do
      user = create(:user)
      election = create(:election)
      paper_authority = create(:user)

      vote = nil

      expect do
        vote = create(:vote, user: user, election: election, paper_authority: paper_authority)
      end.to change(Vote, :count).by(1)

      expect(vote.voter_id).not_to be_nil
      expect(vote.agora_id).not_to be_nil
      expect(vote.user_id).to eq(user.id)
      expect(vote.election_id).to eq(election.id)
      expect(vote.paper_authority_id).to eq(paper_authority.id)
    end

    it 'completes URL generation workflow' do
      vote = create(:vote)

      # Generate voter_id
      voter_id = vote.generate_voter_id
      expect(voter_id).not_to be_nil

      # Generate message
      message = vote.generate_message
      expect(message).to include(voter_id)

      # Generate hash
      hash = vote.generate_hash(message)
      expect(hash).not_to be_nil

      # Generate URL
      url = vote.url
      expect(url).to include(hash)
      expect(url).to include(message)
    end

    it 'enforces voter_id uniqueness within user but not across users' do
      election = create(:election)
      user1 = create(:user)
      user2 = create(:user)

      # Create first vote for user1
      vote1 = create(:vote, user: user1, election: election)

      # Try to create another vote with same voter_id for user1 (should fail)
      vote2 = build(:vote, user: user1, election: election)
      vote2.voter_id = vote1.voter_id
      expect(vote2).not_to be_valid

      # Create vote with same voter_id for user2 (should succeed)
      vote3 = build(:vote, user: user2, election: election)
      vote3.voter_id = vote1.voter_id
      expect(vote3).to be_valid
    end

    it 'handles soft delete and restore workflow' do
      vote = create(:vote)
      original_voter_id = vote.voter_id

      # Soft delete
      expect { vote.destroy }.to change(Vote, :count).by(-1)

      expect(vote.deleted_at).not_to be_nil
      expect(Vote.all).not_to include(vote)
      expect(Vote.with_deleted).to include(vote)

      # Restore
      vote.restore

      expect(vote.reload.deleted_at).to be_nil
      expect(Vote.all).to include(vote)
      expect(vote.voter_id).to eq(original_voter_id)
    end

    it 'handles multiple votes for same user in different elections' do
      user = create(:user)
      election1 = create(:election)
      election2 = create(:election)

      vote1 = create(:vote, user: user, election: election1)
      vote2 = create(:vote, user: user, election: election2)

      expect(vote1.voter_id).not_to eq(vote2.voter_id)
      expect(vote1.user_id).to eq(user.id)
      expect(vote2.user_id).to eq(user.id)
    end
  end
end
